# 无人艇靠离泊感知系统开发计划 2.0

**项目目标**：在现有点云可视化与录制/回放系统基础上，面向“一船多雷达、多船型、多码头形状（直线/L/U 型）”场景，开发一套可实际工程落地的靠离泊实时感知系统。系统需支持：

- 点云数据录制/回放，便于离线算法迭代；
- 多雷达、多实例部署（每个雷达一个进程），通过时间同步与统一协议协同工作；
- 环境去噪与预处理，突出码头/岸线特征；
- 码头岸线识别（先支持直线，逐步扩展到多岸线/U 型）；
- 相对位姿解算（距离、偏角），在**船体坐标系**下输出；
- 面向控制系统的 UDP 通信接口，携带雷达在船体上的位姿信息；
- Headless（无界面）部署，适配工控机长期运行。

**整体周期预估**：约 4-5 周（不含长期实船调试），按阶段逐步交付可用版本。

**最后更新**：2025-12-31

---

## 第一阶段：数据基础设施 ✅ 已完成

**目标**：实现点云数据的离线存储与回放，为后续算法开发提供“原材料”。

> 当前代码中 `Streamer` / `Replayer` / `DeviceManager` 已完成 `.lgv` 格式实现与录制/回放逻辑。本阶段只补充多雷达、多实例使用约定。

### 1.1 自定义数据格式 (.lgv)

- **模块**：`Streamer`
- **现状**：
  - `FileHeader` 含固定 magic ("LGV1") 与版本号；
  - 每帧按顺序写入：`Pose`（含 timestamp_ns）+ 点数 + 点云数据 (PackedPoint: x, y, z, intensity)。
- **补充约定（文档级，不改格式）**：
  - 对于“一船多雷达”场景：
    - 每个雷达由 **独立进程** 负责，产出独立 `.lgv` 文件；
    - 文件命名建议：`<ship_id>_<sensor_id>_<scenario>_<timestamp>.lgv`；
    - 在记录表/日志中写明：
      - `ship_id`（船只编号）
      - `sensor_id`（雷达编号）
      - 雷达在船体坐标系中的外参（安装位置与朝向）。

### 1.2 录制功能

- **模块**：`DeviceManager` → `Replayer` → `Streamer`
- **功能**：
  - 独立写线程，避免 I/O 阻塞采集；
  - 支持多文件录制（按用户选择路径）。
- **多雷达建议**：
  - 每个雷达实例单独启动一个 `linger_perceiver` 进程；
  - 采集时确保所有进程运行在**时间已同步**的主机（同一工控机或同一时间源）。

### 1.3 回放功能

- **模块**：`Replayer` / `DeviceManager`
- **功能**：
  - 支持倍速、暂停/恢复、进度拖拽、预加载等；
  - 回放时通过 `onFrameWithPose` 回调送入 `PointCloudProcessor`，与实时数据处理路径一致。

**阶段状态**：✅ 已完成
- ✅ `.lgv` 文件格式定义与读写（`Streamer`）
- ✅ 录制功能（异步写线程，UI 录制按钮，丢帧检测）
- ✅ 回放功能（倍速 0.5x-8x、暂停/恢复、进度拖拽、Seek 预加载）
- ✅ 多雷达约定文档化（每进程独立 `.lgv`，命名规范）

---

## 第二阶段：现场数据采集与标定 ⏳ 待执行

**目标**：获取覆盖多种工况的高质量点云数据，并完成每艘船、每个雷达的安装参数标定，为算法验证提供“真值”基准。

### 2.1 雷达安装与配置

- **任务**：
  - 按照工程方案，将 Livox 雷达安装在船首、左舷、右舷等位置，确保固定可靠；
  - 为每个雷达实例配置检测扇区参数（通过 `app_config.json`）：
    - `sector_x/y/z_min/max`：根据雷达安装方向设置检测范围；
    - `sensor_id`：雷达编号（1=前, 2=左舷, 3=右舷），用于控制系统区分数据来源；
  - 测量并**在部署文档中记录**（非代码配置）：
    - 雷达中心到水面的垂直距离（用于 `SeaSurfaceFilter` 配置）；
    - 雷达在船体上的安装位置（供控制系统做坐标融合参考）。
- **设计原则**：
  - 感知系统输出**雷达坐标系下的原始距离/角度**；
  - 坐标转换（雷达→船体）由**控制系统**负责，便于灵活调整。

### 2.2 多码头、多工况数据采集

- **任务**：采集多类场景 `.lgv` 数据，并编制对照表：
  1. **直线码头场景**（基础场景）：
     - 静态：5m/10m/20m 距离，多种夹角（0°/30°/45°/60°）；
     - 动态：完整靠泊/离泊过程。
  2. **L 形 / U 形码头场景**（扩展场景）：
     - 至少采集：
       - 船在 U 形内侧靠泊某一边；
       - 船接近 L 形转角区域；
     - 记录：当前所处泊位边（哪条边是“目标边”），大致开口方向。
  3. **干扰与复杂环境场景**：
     - 岸边有轮胎、缆桩、护栏等突出物；
     - 有其他船只或移动目标在视野中。
- **多雷达协同录制**（待条件具备）：
  - 需多台雷达、时间同步环境，暂不作为必要交付项；
  - 单雷达数据已足够验证算法和控制集成。

**预估工时**：1-2 天（视现场安排与天气而定）  
**交付物**：
- 每个雷达实例的 `app_config.json`（含扇区参数、sensor_id）；
- 多套 `.lgv` 文件及配套"真值"记录（实际距离、角度、环境描述）；
- 部署文档：雷达安装位置记录表（供控制系统参考）。

**阶段状态**：⏳ 待执行（依赖现场条件）
- ✅ 已采集部分测试数据（`berthing.lgv`、`unberthing.lgv`、`side_5m_30°.lgv`）
- 📋 需补充：多码头场景数据、真值记录
- ⏸️ 多雷达协同录制：待条件具备

---

## 第三阶段：感知预处理算法 ✅ 已完成

**目标**：从原始点云中剔除船体自身、海面和明显噪声，只保留与码头相关的有效点云，为后续岸线识别提供干净输入。

### 3.1 感兴趣区域裁剪（ROI）

- **模块**：`PointCloudProcessor` → `Filter` 管线
- **实现**：新增 `CropBoxFilter` 封装 `pcl::CropBox`
- **任务**：
  - 根据**雷达安装位置**和作业模式（前向靠泊 / 侧向靠泊），在传感器坐标系或船体坐标系中定义 ROI：
    - 如：前向模式下保留 `[0, 50]m` 前方、左右各 `[-20, 20]m` 的区域；
  - 从点云中剔除船体自身和背向区域点。
- **参数**：从实例配置文件读取（不同雷达/不同船型可不同）。

### 3.2 海面滤除

- **模块**：`PointCloudProcessor` → `SeaSurfaceFilter`
- **实现**：自定义基于 Z 的滤波，必要时参考 `pcl::PassThrough`
- **任务**：
  - 利用标定得到的“雷达至水面垂直高度”，推算水面所在的 Z 值；
  - 对低于（海面高度 + 安全裕度）的点进行滤除，减弱浪花/反射；
  - 可按不同船型调节裕度参数。

### 3.3 离群点与噪声去除

- **模块**：`PointCloudProcessor` → `StatisticalOutlierFilter`
- **实现**：基于 `pcl::StatisticalOutlierRemoval` 或 `RadiusOutlierRemoval` 的封装
- **任务**：
  - 去除孤立点、稀疏噪点，提升后续 RANSAC 稳定性；
  - 参数（`mean_k`, `std_dev_mul`）可由配置或 UI 调整。

**预估工时**：3-4 天  
**交付物**：
- 一组可配置滤波器（距离、ROI、海面滤除、离群点）；
- 在 UI 中查看到的点云已足够干净，仅保留码头及岸上主要结构。

**阶段状态**：✅ 已完成
- ✅ `DistanceFilter`：距离滤波（min/max），可配置启用
- ✅ `CropBoxFilter`：ROI 裁剪（6 边界参数），可配置启用
- ✅ `SeaSurfaceFilter`：海面滤除（sea_level_z + margin），可配置启用
- ✅ `StatisticalOutlierFilter`：统计离群点去除（mean_k, stddev_mul），可配置启用
- ✅ `VoxelFilter`：体素下采样（leaf_size），可配置启用
- ✅ `DensityFilter`：密度滤波（voxel_size, min_points），低密度噪声去除
- ✅ `MotionFilter`：运动滤波（cell_size, threshold），静态/动态点分离
- ✅ `Filter` 基类与管线化设计（`PointCloudProcessor` 支持 pre/post filter 链）
- ✅ `AppConfig` JSON 配置加载/保存（`config/app_config.json`）
- ✅ UI 滤波器参数面板（实时调整，`filterStack` 切换）

---

## 第四阶段：岸线识别与靠泊状态估计 ✅ 已完成

**目标**：从预处理后的点云中识别码头岸线几何特征，并在 **船体坐标系** 下输出距离与偏角等靠泊状态。针对实际工程复杂度，将道路分为多个演进版本（V1/V2/V3）。

> **当前工程策略说明**：在“一船多雷达”的部署方案下，本版本采用“**单实例单扇区单岸线**”策略——每个雷达实例只在自己负责的方位扇区内检测一条目标岸线，不在单个实例内做多岸线/多雷达融合。V2/V3 主要面向“单雷达覆盖多方向”或“未来多雷达融合到单进程”的扩展需求，本轮实现重点是各实例内的 V1 能力。

### 4.1 算法模块化：`DockingAlgorithm`

- **模块**：新增 `DockingAlgorithm`（独立于 `PointCloudProcessor`）
- **职责划分**：
  1. `PreProcessor`：调用上述滤波器串联（ROI/海面/去噪）；
  2. `ShorelineDetector`：根据模式在特定扇区内拟合岸线；
  3. `StateEstimator`：
     - 在船体坐标系下计算距离 $D$、偏角 $\theta$；
     - 根据内点数等计算置信度；
     - 输出 `DockingState` 结构体（距离、角度、置信度、状态码、岸线参数等）。

### 4.2 V1：单直线岸线模式 ✅ 已完成

- **适用场景**：直线码头，船首正对或小角度斜对。
- **任务**：
  - 将 3D 点云投影到 2D（XY 平面），忽略 Z；
  - 在**前向扇区**内使用 RANSAC 拟合**一条主直线**；
  - 得到直线方程 $Ax + By + C = 0$；
  - 在**船体坐标系 B** 下，计算：
    - 船体参考点到岸线的垂直距离 $D$；
    - 船首方向与岸线方向的夹角 $\theta$；
  - 给出 RANSAC 内点数、残差等置信度指标。

### 4.3 V2：多扇区、多线段支持（预研）

- **适用场景**：
  - 仅装一台雷达、却需要同时感知前向和一侧岸线的船型；
  - 或未来将多雷达点云统一到单一进程内部时，在一个进程内做多扇区识别。
- **任务（预研方向，当前项目中可不实现或部分实现）**：
  - 在单实例内部，将点云按方位角分为若干扇区（例如：前向/左舷/右舷）；
  - 在每个扇区单独执行 RANSAC 拟合，得到多条岸线段；
  - 在算法/配置中支持**作业模式**切换：
    - `front_docking`：优先使用前向扇区的岸线；
    - `side_docking_port`：优先使用左舷扇区的岸线；
    - `side_docking_starboard`：优先使用右舷扇区的岸线；
  - 为每条线分别计算距离/偏角，便于控制策略或融合模块在未来按需选取。

### 4.4 V3：U 形与复杂码头场景（长期扩展）

- **适用场景**：
  - U 型港池内部靠泊；
  - 多条岸线同时可见，需要区分“目标边”和“对岸边”。
- **任务（规划性，当前阶段可预留接口）**：
  - 利用 V2 的多线段结果 + 环境配置（开口方向、泊位边索引），对线段关系进行分析：
    - 识别当前靠泊目标边；
    - 推算对岸的最短距离（用于防撞对岸）。
  - `DockingState` 中扩展结构，支持多条岸线状态的输出。

### 4.5 算法可视化与调试支持

- **模块**：`Renderer`
- **任务**：
  - 绘制前/左/右扇区边界线；
  - 为每条拟合岸线绘制彩色线段，并标注来源扇区（Front/Port/Starboard）；
  - 在 UI 中实时显示：
    - 当前模式、选中扇区；
    - 距离、角度、置信度等数值。

**预估工时**：
- V1：5-7 天（实现与调试），为本项目阶段的主要工作量；
- V2/V3：作为后续版本/单雷达复杂场景与多雷达融合的扩展预留，当前仅做方案和接口层面的预研，不强制在本轮交付中全部落地。

**交付物**：
- `DockingAlgorithm` 模块及其头文件/实现；
- 在 UI 中实时显示“距离 D、角度 θ、置信度 C”，并能查看拟合岸线效果。

**阶段状态**：✅ 已完成（2025-12-24 更新）
- ✅ `DockingAlgorithm` 模块已实现（含 V1 算法）
- ✅ 最近区域距离检测（`detectNearestRegion`）
- ✅ RANSAC 直线拟合（`fitLineRansac`）+ 边缘检测（`detectDockEdge`）
- ✅ 距离/角度状态估计（`DockingState` 结构体）
- ✅ 交叉验证机制（`crossValidate`）
- ✅ 可视化叠加显示（VTK 渲染器集成，圆弧+直线+文本）
- ✅ UI 参数调整面板（实时调参 + JSON 配置持久化）
- 📋 V2/V3 扩展：多扇区、U 型码头（预留接口）

---

## 第五阶段：通信与系统集成 ✅ 已完成

**目标**：将感知结果通过 UDP 协议发送给控制系统。每个雷达实例独立发送，由控制系统负责融合和坐标转换。

### 5.1 通信协议定义

- **模块**：`include/communication/docking_packet.h`
- **结构体定义**：

```cpp
#pragma pack(push, 1)
struct DockingPacket {
    uint64_t timestamp_ns;   // 时间戳（纳秒）
    uint8_t  sensor_id;      // 雷达编号 (1=前, 2=左舷, 3=右舷)
    uint8_t  status;         // 0:未检测, 1:正常, 2:低置信度
    uint8_t  confidence;     // 0-100
    uint8_t  reserved;       // 保留（对齐）
    float    distance_m;     // 雷达检测距离（雷达坐标系）
    float    angle_deg;      // 边缘角度（如有，否则为0）
};  // 共 20 字节
#pragma pack(pop)
```

- **设计说明**：
  - 不含雷达外参（`sensor_x/y/z/yaw`），坐标转换由控制系统负责；
  - 小端字节序，1 字节对齐；
  - `sensor_id` 与安装位置的映射关系在部署文档中约定。

### 5.2 发送模块实现：`DockingPublisher`

- **模块**：`include/communication/docking_publisher.h`, `src/communication/docking_publisher.cpp`
- **已实现功能**：
  - ✅ 创建 UDP Socket，按配置的 IP/端口发送 `DockingPacket`；
  - ✅ 异步发送线程，避免阻塞算法/渲染线程；
  - ✅ 从 `app_config.json` 读取 `sensor_id`、目标 IP/端口；
  - ✅ 集成到 `main.cpp` 和 `main_headless.cpp`。
- **配置项**（`app_config.json`）：
  ```json
  "udp_enabled": true,
  "udp_target_ip": "127.0.0.1",
  "udp_target_port": 5000,
  "udp_sensor_id": 1
  ```

### 5.3 异常处理与安全机制

- **已实现**：
  - ✅ 根据 `DockingState` 自动判断状态：
    - `NO_DETECTION`：未检测到岸线；
    - `NORMAL`：正常检测；
    - `LOW_CONFIDENCE`：置信度低于阈值。
  - ⏳ **数据平滑**：待后续集成（滑动平均或一阶滤波）。

### 5.4 测试工具

- **模块**：`tools/udp_receiver.cpp`
- **功能**：独立 UDP 接收程序，格式化显示收到的 `DockingPacket`；
- **编译**：`tools/build_udp_receiver.bat` 或手动 MSVC 编译。

**预估工时**：2-3 天 → **实际完成**  
**交付物**：
- ✅ `DockingPublisher` 模块（支持 UDP 发送）；
- ✅ 通信协议头文件 `docking_packet.h`；
- ✅ UDP 接收测试工具；
- ⏳ 超时保护与数据平滑待后续完善。

**阶段状态**：✅ 已完成（基础功能）
- ✅ `DockingPublisher` UDP 发送模块
- ✅ 通信协议头文件 `docking_packet.h`
- ✅ GUI 模式集成（`main.cpp`）
- ✅ Headless 模式集成（`main_headless.cpp`）
- ✅ UDP 接收测试工具
- ⏳ 数据平滑待后续完善

---

## 第六阶段：现场调试与多环境适配 ⏳ 待执行

**目标**：在真实海况、不同码头形状与多雷达部署条件下，验证系统稳定性并调优参数。

### 6.1 静态精度验证

- 比对 `DockingAlgorithm` 输出与实测距离/角度差异；
- 针对不同船型和雷达安装位置，校准：
  - 水面高度、ROI 范围、RANSAC 距离阈值等参数。

### 6.2 动态靠泊/离泊测试

- 在不同码头与不同作业模式下录制实船靠泊/离泊过程；
- 检查输出的距离/角度曲线是否平滑、是否有跳变或异常丢失。

### 6.3 多雷达协同与配置沉淀

- 验证：
  - 多实例运行下各雷达数据时间线是否一致；
  - 控制系统是否能按 `sensor_id` 正确使用各路感知结果；
- 将稳定参数固化为：
  - 每艘船一套参数合集；
  - 每类码头一套环境参数（直线/L/U 型等）。

**预估工时**：持续进行  
**交付物**：
- 一组稳定的配置文件组合（按船型/码头分类）；
- 调试报告与问题清单，为后续 V2/V3 算法扩展提供依据。

**阶段状态**：⏳ 待执行（依赖 Phase 4/5 完成）

---

## 第七阶段：Headless 多实例部署 ✅ 基础框架已完成

**目标**：在工控机上以 **无界面服务模式** 部署多个雷达实例，长期稳定运行。

### 7.1 架构解耦与入口拆分

- **模块**：
  - `main.cpp`（带 UI 的调试版本，保持不变）；
  - 新增 `main_headless.cpp`（生产部署版本）。
- **任务**：
  - 在 `main_headless.cpp` 中：
    - 不使用 Qt/VTK，仅保留 `DeviceManager`、`PointCloudProcessor`、`DockingAlgorithm`、`DockingPublisher`；
    - 从命令行参数或配置文件路径启动不同实例；
    - 注册信号处理（如 Ctrl+C）以正确关闭设备与线程。
  - 在 CMake 中新增 `BUILD_HEADLESS` 选项：
    - `ON` 时不链接 Qt/VTK，仅生成 `linger_perceiver_service`；
    - `OFF` 时生成原有带界面版本。
  - **日志存放位置**：`log/<日期>/linger_headless.log`（自动按日期滚动，单文件最大 5MB，最多 5 个滚动文件）。

### 7.2 多实例部署与运维

- **核心设计**：通过修改 `app_config.json` 实现不同方向的检测配置，无需重新编译：
  - `sensor_id`：区分雷达实例（1=前, 2=左舷, 3=右舷）
  - `sector_*` 参数：配置检测扇区范围
  - `udp_target_ip/port`：指定 UDP 目标

- **多进程配置示例**：
  ```
  config/
  ├── app_config_front.json      # 前向雷达：sensor_id=1
  ├── app_config_port.json       # 左舷雷达：sensor_id=2
  └── app_config_starboard.json  # 右舷雷达：sensor_id=3
  ```

- **启动命令**：
  ```powershell
  # 前向雷达实例
  .\linger_perceiver_service.exe --config mid360_front.json --app-config config/app_config_front.json
  
  # 左舷雷达实例
  .\linger_perceiver_service.exe --config mid360_port.json --app-config config/app_config_port.json
  
  # 右舷雷达实例
  .\linger_perceiver_service.exe --config mid360_starboard.json --app-config config/app_config_starboard.json
  
  # 回放模式测试
  .\linger_perceiver_service.exe --replay berthing.lgv --app-config config/app_config.json
  ```

- **关键配置差异**（以前向 vs 左舷为例）：
  | 参数 | 前向 (Front) | 左舷 (Port) | 右舷 (Starboard) |
  |------|-------------|-------------|------------------|
  | `udp_sensor_id` | 1 | 2 | 3 |
  | `nr_sector_x_min/max` | 0.1 ~ 50 | -50 ~ 0.1 (或旋转) | 同左舷对称 |
  | `nr_sector_y_min/max` | -15 ~ 15 | 根据安装方向 | 根据安装方向 |

- **规范日志文件命名与轮转策略**：
  - 日志目录：`log/<日期>/`
  - 自动滚动：单文件 5MB，每天最多 5 个滚动文件
  - 文件名：`linger_headless.log`（可通过 `--log` 参数自定义基础名称）

**预估工时**：3-4 天  
**交付物**：
- `linger_perceiver_service` 可执行文件及多实例启动配置示例；
- 部署说明文档（可作为运维手册的一部分）。

**阶段状态**：✅ 已完成
- ✅ `main_headless.cpp` 无界面入口已实现
- ✅ 命令行参数解析（`-c/--config`、`--app-config`、`--log`、`-r/--replay`）
- ✅ 信号处理（Ctrl+C 优雅退出）
- ✅ 日志滚动（`log/<日期>/linger_headless.log`，按大小滚动，spdlog）
- ✅ 滤波器管线已集成
- ✅ `DockingAlgorithm` 靠泊检测已集成
- ✅ `DockingPublisher` UDP 通信已集成
- ✅ 回放模式支持（`--replay` 参数）
- 📋 待完善：多实例启动脚本模板

---

## 里程碑与时间规划（更新于 2025-12-31）

| 阶段 | 重点任务 | 预计耗时 | 状态 | 关键产出 |
| :--- | :--- | :--- | :--- | :--- |
| **Phase 1** | 数据基础设施与多雷达约定 | - | ✅ 已完成 | `.lgv` 读写、录制/回放、多实例规范 |
| **Phase 2** | 多雷达、多船型、多码头数据采集与标定 | 1-3 天 | ⏳ 部分完成 | 配置文件+多场景数据集 |
| **Phase 3** | ROI/海面/离群点预处理 | - | ✅ 已完成 | 7 种滤波器、JSON 配置、UI 面板 |
| **Phase 4** | 岸线识别与状态估计（V1+预留 V2/V3） | - | ✅ **已完成** | `DockingAlgorithm` + 可视化 + UI |
| **Phase 5** | 多雷达 UDP 通信与异常保护 | - | ✅ **已完成** | 统一协议 + `DockingPublisher` |
| **Phase 6** | 实船多环境调试与参数沉淀 | 持续 | ⏳ 待执行 | 各船型/码头参数集 |
| **Phase 7** | Headless 多实例部署 | - | ✅ **已完成** | `main_headless.cpp`、日志滚动 |

### 当前进度概览

```
Phase 1: ████████████████████ 100%  ✅ 数据基础设施
Phase 2: ████████░░░░░░░░░░░░  40%  ⏳ 数据采集（部分）
Phase 3: ████████████████████ 100%  ✅ 预处理算法
Phase 4: ████████████████████ 100%  ✅ 岸线识别（V1 完成）
Phase 5: ████████████████████ 100%  ✅ UDP 通信
Phase 6: ░░░░░░░░░░░░░░░░░░░░   0%  ⏳ 现场调试
Phase 7: ████████████████████ 100%  ✅ Headless 部署
```

---

## 附录（可复用 1.0 版内容并按多雷达场景更新）

- **附录 A：数据采集场景清单**（扩展为多雷达、多码头版本）；
- **附录 B：现场测量任务**（增加雷达-船体外参、U 型码头环境记录项）；
- **附录 C：软件配置与硬件需求**（补充多实例运行的资源估算）。

---

## 已实现模块清单

### 核心模块

| 模块 | 头文件 | 实现文件 | 描述 |
| :--- | :--- | :--- | :--- |
| `DeviceManager` | `device_manager.h` | `device_manager.cpp` | Livox 设备管理 Facade |
| `DataProcessor` | `data_processor.h` | `data_processor.cpp` | IMU 融合、时间同步、姿态解算 |
| `PointCloudProcessor` | `processor.h` | `processor.cpp` | 点云帧队列、滤波管线、快照发布 |
| `Renderer` | `renderer.h` | `renderer.cpp` | VTK 点云渲染 |
| `Streamer` | `streamer.h` | `streamer.cpp` | `.lgv` 文件读写 |
| `Replayer` | `replayer.h` | `replayer.cpp` | 回放控制（倍速/暂停/Seek） |

### 算法模块

| 模块 | 头文件 | 实现文件 | 描述 |
| :--- | :--- | :--- | :--- |
| `DockingAlgorithm` | `docking_algorithm.h` | `docking_algorithm.cpp` | 靠泊检测（最近区域+边缘检测） |
| `DockingTypes` | `docking_types.h` | - | 数据类型定义（状态/配置/结果） |

### 滤波器模块

| 滤波器 | 头文件 | 实现文件 | 描述 |
| :--- | :--- | :--- | :--- |
| `DistanceFilter` | `distance_filter.h` | `distance_filter.cpp` | 距离范围过滤 |
| `CropBoxFilter` | `crop_box_filter.h` | `crop_box_filter.cpp` | ROI 裁剪 |
| `SeaSurfaceFilter` | `sea_surface_filter.h` | `sea_surface_filter.cpp` | 海面滤除 |
| `StatisticalOutlierFilter` | `statistical_outlier_filter.h` | `statistical_outlier_filter.cpp` | 统计离群点去除 |
| `VoxelFilter` | `voxel_filter.h` | `voxel_filter.cpp` | 体素下采样 |
| `DensityFilter` | `density_filter.h` | `density_filter.cpp` | 密度滤波（低密度噪声去除） |
| `MotionFilter` | `motion_filter.h` | `motion_filter.cpp` | 运动滤波（静态/动态分离） |

### 配置与工具

| 模块 | 文件 | 描述 |
| :--- | :--- | :--- |
| `AppConfig` | `app_config.h/cpp` | JSON 配置加载/保存 |
| `Logger` | `logger.h` | spdlog 日志封装（按日期目录+滚动） |
| `ColorMap` | `color_map.h/cpp` | 点云着色方案 |
| `CameraInteractor` | `camera_interactor.h/cpp` | VTK 相机交互器 |

### UI 组件

| 组件 | 文件 | 描述 |
| :--- | :--- | :--- |
| `PointCloudWgt` | `point_cloud_wgt.h/cpp` | 主窗口控件 |
| UI 定义 | `ui/point_cloud_wgt.ui` | Qt Designer UI |
