# 无人艇靠离泊感知系统开发计划 2.0

**项目目标**：在现有点云可视化与录制/回放系统基础上，面向“一船多雷达、多船型、多码头形状（直线/L/U 型）”场景，开发一套可实际工程落地的靠离泊实时感知系统。系统需支持：

- 点云数据录制/回放，便于离线算法迭代；
- 多雷达、多实例部署（每个雷达一个进程），通过时间同步与统一协议协同工作；
- 环境去噪与预处理，突出码头/岸线特征；
- 码头岸线识别（先支持直线，逐步扩展到多岸线/U 型）；
- 相对位姿解算（距离、偏角），在**船体坐标系**下输出；
- 面向控制系统的 UDP 通信接口，携带雷达在船体上的位姿信息；
- Headless（无界面）部署，适配工控机长期运行。

**整体周期预估**：约 4-5 周（不含长期实船调试），按阶段逐步交付可用版本。

**最后更新**：2025-12-11

---

## 第一阶段：数据基础设施 ✅ 已完成

**目标**：实现点云数据的离线存储与回放，为后续算法开发提供“原材料”。

> 当前代码中 `Streamer` / `Replayer` / `DeviceManager` 已完成 `.lgv` 格式实现与录制/回放逻辑。本阶段只补充多雷达、多实例使用约定。

### 1.1 自定义数据格式 (.lgv)

- **模块**：`Streamer`
- **现状**：
  - `FileHeader` 含固定 magic ("LGV1") 与版本号；
  - 每帧按顺序写入：`Pose`（含 timestamp_ns）+ 点数 + 点云数据 (PackedPoint: x, y, z, intensity)。
- **补充约定（文档级，不改格式）**：
  - 对于“一船多雷达”场景：
    - 每个雷达由 **独立进程** 负责，产出独立 `.lgv` 文件；
    - 文件命名建议：`<ship_id>_<sensor_id>_<scenario>_<timestamp>.lgv`；
    - 在记录表/日志中写明：
      - `ship_id`（船只编号）
      - `sensor_id`（雷达编号）
      - 雷达在船体坐标系中的外参（安装位置与朝向）。

### 1.2 录制功能

- **模块**：`DeviceManager` → `Replayer` → `Streamer`
- **功能**：
  - 独立写线程，避免 I/O 阻塞采集；
  - 支持多文件录制（按用户选择路径）。
- **多雷达建议**：
  - 每个雷达实例单独启动一个 `linger_perceiver` 进程；
  - 采集时确保所有进程运行在**时间已同步**的主机（同一工控机或同一时间源）。

### 1.3 回放功能

- **模块**：`Replayer` / `DeviceManager`
- **功能**：
  - 支持倍速、暂停/恢复、进度拖拽、预加载等；
  - 回放时通过 `onFrameWithPose` 回调送入 `PointCloudProcessor`，与实时数据处理路径一致。

**阶段状态**：✅ 已完成
- ✅ `.lgv` 文件格式定义与读写（`Streamer`）
- ✅ 录制功能（异步写线程，UI 录制按钮，丢帧检测）
- ✅ 回放功能（倍速 0.5x-8x、暂停/恢复、进度拖拽、Seek 预加载）
- ✅ 多雷达约定文档化（每进程独立 `.lgv`，命名规范）

---

## 第二阶段：现场数据采集与标定 ⏳ 待执行

**目标**：获取覆盖多种工况的高质量点云数据，并完成每艘船、每个雷达的安装参数标定，为算法验证提供“真值”基准。

### 2.1 雷达安装与几何标定

- **任务**：
  - 按照工程方案，将 Livox 雷达安装在船首、左舷、右舷等位置，确保固定可靠；
  - 为每个雷达实例测量并记录：
    - 雷达中心在**船体坐标系 B** 下的位置 $(x, y, z)$：
      - 原点建议约定为：船体几何中心或控制系统指定基准点；
      - $x$ 轴指向船首，$y$ 向左舷，$z$ 向上；
    - 雷达相对于船体的朝向（至少 yaw，必要时 pitch/roll）；
    - 雷达中心到水面的垂直距离（用于海面滤除）。
  - 将上述参数写入**实例配置文件**（例如 `config_front.json`、`config_port.json`）。

### 2.2 多码头、多工况数据采集

- **任务**：采集多类场景 `.lgv` 数据，并编制对照表：
  1. **直线码头场景**（基础场景）：
     - 静态：5m/10m/20m 距离，多种夹角（0°/30°/45°/60°）；
     - 动态：完整靠泊/离泊过程。
  2. **L 形 / U 形码头场景**（扩展场景）：
     - 至少采集：
       - 船在 U 形内侧靠泊某一边；
       - 船接近 L 形转角区域；
     - 记录：当前所处泊位边（哪条边是“目标边”），大致开口方向。
  3. **干扰与复杂环境场景**：
     - 岸边有轮胎、缆桩、护栏等突出物；
     - 有其他船只或移动目标在视野中。
- **多雷达协同录制建议**：
  - 若条件允许，同时启动多进程（前/左/右雷达），在同一船上同步录制；
  - 数据记录表中需将同一试验编号下的各雷达文件关联起来。

**预估工时**：1-3 天（视现场安排与天气而定）  
**交付物**：
- 每个雷达实例的配置文件（包含安装参数）；
- 多套 `.lgv` 文件及配套“真值”记录（实际距离、角度、环境描述）。

**阶段状态**：⏳ 待执行（依赖现场条件）
- ⏸️ 已采集部分测试数据（`berthing.lgv`、`unberthing.lgv`、`side_5m_30°.lgv`）
- 📋 需补充：多雷达外参标定、多码头场景数据

---

## 第三阶段：感知预处理算法 ✅ 已完成

**目标**：从原始点云中剔除船体自身、海面和明显噪声，只保留与码头相关的有效点云，为后续岸线识别提供干净输入。

### 3.1 感兴趣区域裁剪（ROI）

- **模块**：`PointCloudProcessor` → `Filter` 管线
- **实现**：新增 `CropBoxFilter` 封装 `pcl::CropBox`
- **任务**：
  - 根据**雷达安装位置**和作业模式（前向靠泊 / 侧向靠泊），在传感器坐标系或船体坐标系中定义 ROI：
    - 如：前向模式下保留 `[0, 50]m` 前方、左右各 `[-20, 20]m` 的区域；
  - 从点云中剔除船体自身和背向区域点。
- **参数**：从实例配置文件读取（不同雷达/不同船型可不同）。

### 3.2 海面滤除

- **模块**：`PointCloudProcessor` → `SeaSurfaceFilter`
- **实现**：自定义基于 Z 的滤波，必要时参考 `pcl::PassThrough`
- **任务**：
  - 利用标定得到的“雷达至水面垂直高度”，推算水面所在的 Z 值；
  - 对低于（海面高度 + 安全裕度）的点进行滤除，减弱浪花/反射；
  - 可按不同船型调节裕度参数。

### 3.3 离群点与噪声去除

- **模块**：`PointCloudProcessor` → `StatisticalOutlierFilter`
- **实现**：基于 `pcl::StatisticalOutlierRemoval` 或 `RadiusOutlierRemoval` 的封装
- **任务**：
  - 去除孤立点、稀疏噪点，提升后续 RANSAC 稳定性；
  - 参数（`mean_k`, `std_dev_mul`）可由配置或 UI 调整。

**预估工时**：3-4 天  
**交付物**：
- 一组可配置滤波器（距离、ROI、海面滤除、离群点）；
- 在 UI 中查看到的点云已足够干净，仅保留码头及岸上主要结构。

**阶段状态**：✅ 已完成
- ✅ `DistanceFilter`：距离滤波（min/max），可配置启用
- ✅ `CropBoxFilter`：ROI 裁剪（6 边界参数），可配置启用
- ✅ `SeaSurfaceFilter`：海面滤除（sea_level_z + margin），可配置启用
- ✅ `StatisticalOutlierFilter`：统计离群点去除（mean_k, stddev_mul），可配置启用
- ✅ `VoxelFilter`：体素下采样（leaf_size），可配置启用
- ✅ `Filter` 基类与管线化设计（`PointCloudProcessor` 支持 pre/post filter 链）
- ✅ `AppConfig` JSON 配置加载/保存（`config/app_config.json`）
- ✅ UI 滤波器参数面板（实时调整，`filterStack` 切换）

---

## 第四阶段：岸线识别与靠泊状态估计 📋 待开发

**目标**：从预处理后的点云中识别码头岸线几何特征，并在 **船体坐标系** 下输出距离与偏角等靠泊状态。针对实际工程复杂度，将道路分为多个演进版本（V1/V2/V3）。

> **当前工程策略说明**：在“一船多雷达”的部署方案下，本版本采用“**单实例单扇区单岸线**”策略——每个雷达实例只在自己负责的方位扇区内检测一条目标岸线，不在单个实例内做多岸线/多雷达融合。V2/V3 主要面向“单雷达覆盖多方向”或“未来多雷达融合到单进程”的扩展需求，本轮实现重点是各实例内的 V1 能力。

### 4.1 算法模块化：`DockingAlgorithm`

- **模块**：新增 `DockingAlgorithm`（独立于 `PointCloudProcessor`）
- **职责划分**：
  1. `PreProcessor`：调用上述滤波器串联（ROI/海面/去噪）；
  2. `ShorelineDetector`：根据模式在特定扇区内拟合岸线；
  3. `StateEstimator`：
     - 在船体坐标系下计算距离 $D$、偏角 $\theta$；
     - 根据内点数等计算置信度；
     - 输出 `DockingState` 结构体（距离、角度、置信度、状态码、岸线参数等）。

### 4.2 V1：单直线岸线模式（当前主要里程碑）

- **适用场景**：直线码头，船首正对或小角度斜对。
- **任务**：
  - 将 3D 点云投影到 2D（XY 平面），忽略 Z；
  - 在**前向扇区**内使用 RANSAC 拟合**一条主直线**；
  - 得到直线方程 $Ax + By + C = 0$；
  - 在**船体坐标系 B** 下，计算：
    - 船体参考点到岸线的垂直距离 $D$；
    - 船首方向与岸线方向的夹角 $\theta$；
  - 给出 RANSAC 内点数、残差等置信度指标。

### 4.3 V2：多扇区、多线段支持（预研）

- **适用场景**：
  - 仅装一台雷达、却需要同时感知前向和一侧岸线的船型；
  - 或未来将多雷达点云统一到单一进程内部时，在一个进程内做多扇区识别。
- **任务（预研方向，当前项目中可不实现或部分实现）**：
  - 在单实例内部，将点云按方位角分为若干扇区（例如：前向/左舷/右舷）；
  - 在每个扇区单独执行 RANSAC 拟合，得到多条岸线段；
  - 在算法/配置中支持**作业模式**切换：
    - `front_docking`：优先使用前向扇区的岸线；
    - `side_docking_port`：优先使用左舷扇区的岸线；
    - `side_docking_starboard`：优先使用右舷扇区的岸线；
  - 为每条线分别计算距离/偏角，便于控制策略或融合模块在未来按需选取。

### 4.4 V3：U 形与复杂码头场景（长期扩展）

- **适用场景**：
  - U 型港池内部靠泊；
  - 多条岸线同时可见，需要区分“目标边”和“对岸边”。
- **任务（规划性，当前阶段可预留接口）**：
  - 利用 V2 的多线段结果 + 环境配置（开口方向、泊位边索引），对线段关系进行分析：
    - 识别当前靠泊目标边；
    - 推算对岸的最短距离（用于防撞对岸）。
  - `DockingState` 中扩展结构，支持多条岸线状态的输出。

### 4.5 算法可视化与调试支持

- **模块**：`Renderer`
- **任务**：
  - 绘制前/左/右扇区边界线；
  - 为每条拟合岸线绘制彩色线段，并标注来源扇区（Front/Port/Starboard）；
  - 在 UI 中实时显示：
    - 当前模式、选中扇区；
    - 距离、角度、置信度等数值。

**预估工时**：
- V1：5-7 天（实现与调试），为本项目阶段的主要工作量；
- V2/V3：作为后续版本/单雷达复杂场景与多雷达融合的扩展预留，当前仅做方案和接口层面的预研，不强制在本轮交付中全部落地。

**交付物**：
- `DockingAlgorithm` 模块及其头文件/实现；
- 在 UI 中实时显示“距离 D、角度 θ、置信度 C”，并能查看拟合岸线效果。

**阶段状态**：📋 待开发（下一优先级）
- 📋 `DockingAlgorithm` 模块待实现
- 📋 RANSAC 直线拟合待实现
- 📋 距离/角度状态估计待实现
- 📋 可视化叠加显示待实现

---

## 第五阶段：通信与系统集成 📋 待开发

**目标**：在“一船多雷达多进程”的部署模式下，将各雷达感知结果通过统一 UDP 协议发送给控制系统，并附带雷达在船体上的位姿信息。

### 5.1 通信协议定义

- **模块**：文档与头文件（详见《配置与通信协议说明》）
- **结构体示例**：

```cpp
struct DockingPacket {
    uint64_t timestamp;      // ns，系统统一时间
    float    distance_m;     // 与目标岸线的垂直距离
    float    angle_deg;      // 船首与岸线的夹角
    uint8_t  confidence;     // 0-100
    uint8_t  status;         // 0:未检测, 1:正常, 2:警告/无效

    // 多雷达扩展字段
    uint8_t  sensor_id;      // 雷达编号（约定映射表）
    uint8_t  reserved;
    float    sensor_x_m;     // 雷达在船体坐标系 B 中的位置/朝向
    float    sensor_y_m;
    float    sensor_z_m;
    float    sensor_yaw_deg;
};
```

- **要求**：
  - 明确字节对齐与大小端约定（默认小端，1 字节对齐）；
  - 在协议文档中给出二进制布局表，便于控制系统解析。

### 5.2 发送模块实现：`DockingPublisher`

- **模块**：新增 `DockingPublisher` 类
- **任务**：
  - 创建 UDP Socket，按配置的 IP/端口发送 `DockingState` 序列化后的 `DockingPacket`；
  - 独立线程或异步队列发送，避免阻塞算法/渲染线程；
  - 读取每个实例的配置（`sensor_id`、`sensor_x/y/z`、`sensor_yaw_deg`），填入数据包。

### 5.3 异常处理与安全机制

- **任务**：
  - **超时保护**：
    - 若在配置时间窗口内（如 500ms）未检测到有效岸线，发送 `status = 2` 且 `confidence = 0`；
  - **数据平滑**：
    - 采用滑动平均或简单一阶滤波，对距离/角度进行平滑，避免控制系统因抖动产生过度动作。

**预估工时**：3-4 天  
**交付物**：
- 控制器可接收多路雷达 UDP 数据，并能区分来源与安装位置；
- 文档中给出的协议格式与控制端实现一致。

**阶段状态**：📋 待开发
- 📋 `DockingPublisher` UDP 发送模块待实现
- 📋 通信协议头文件待实现
- 📋 超时保护与数据平滑待实现

---

## 第六阶段：现场调试与多环境适配 ⏳ 待执行

**目标**：在真实海况、不同码头形状与多雷达部署条件下，验证系统稳定性并调优参数。

### 6.1 静态精度验证

- 比对 `DockingAlgorithm` 输出与实测距离/角度差异；
- 针对不同船型和雷达安装位置，校准：
  - 水面高度、ROI 范围、RANSAC 距离阈值等参数。

### 6.2 动态靠泊/离泊测试

- 在不同码头与不同作业模式下录制实船靠泊/离泊过程；
- 检查输出的距离/角度曲线是否平滑、是否有跳变或异常丢失。

### 6.3 多雷达协同与配置沉淀

- 验证：
  - 多实例运行下各雷达数据时间线是否一致；
  - 控制系统是否能按 `sensor_id` 正确使用各路感知结果；
- 将稳定参数固化为：
  - 每艘船一套参数合集；
  - 每类码头一套环境参数（直线/L/U 型等）。

**预估工时**：持续进行  
**交付物**：
- 一组稳定的配置文件组合（按船型/码头分类）；
- 调试报告与问题清单，为后续 V2/V3 算法扩展提供依据。

**阶段状态**：⏳ 待执行（依赖 Phase 4/5 完成）

---

## 第七阶段：Headless 多实例部署 ✅ 基础框架已完成

**目标**：在工控机上以 **无界面服务模式** 部署多个雷达实例，长期稳定运行。

### 7.1 架构解耦与入口拆分

- **模块**：
  - `main.cpp`（带 UI 的调试版本，保持不变）；
  - 新增 `main_headless.cpp`（生产部署版本）。
- **任务**：
  - 在 `main_headless.cpp` 中：
    - 不使用 Qt/VTK，仅保留 `DeviceManager`、`PointCloudProcessor`、`DockingAlgorithm`、`DockingPublisher`；
    - 从命令行参数或配置文件路径启动不同实例；
    - 注册信号处理（如 Ctrl+C）以正确关闭设备与线程。
  - 在 CMake 中新增 `BUILD_HEADLESS` 选项：
    - `ON` 时不链接 Qt/VTK，仅生成 `linger_perceiver_service`；
    - `OFF` 时生成原有带界面版本。

### 7.2 多实例部署与运维

- **任务**：
  - 设计启动脚本/服务配置：
    - 例如在 Windows 下通过任务计划或服务管理，分别启动：
      - `linger_perceiver_service --config config_front.json`
      - `linger_perceiver_service --config config_port.json`
      - `linger_perceiver_service --config config_starboard.json`
  - 规范日志文件命名与轮转策略（每个实例独立日志）。

**预估工时**：3-4 天  
**交付物**：
- `linger_perceiver_service` 可执行文件及多实例启动配置示例；
- 部署说明文档（可作为运维手册的一部分）。

**阶段状态**：✅ 基础框架已完成
- ✅ `main_headless.cpp` 无界面入口已实现
- ✅ 命令行参数解析（`-c/--config`、`--app-config`、`--log`）
- ✅ 信号处理（Ctrl+C 优雅退出）
- ✅ 日志滚动（按日期目录 + 按大小滚动，spdlog）
- ✅ 滤波器管线已集成
- 📋 待完善：`DockingAlgorithm` 与 `DockingPublisher` 集成（依赖 Phase 4/5）
- 📋 待完善：多实例启动脚本与服务配置

---

## 里程碑与时间规划（更新于 2025-12-11）

| 阶段 | 重点任务 | 预计耗时 | 状态 | 关键产出 |
| :--- | :--- | :--- | :--- | :--- |
| **Phase 1** | 数据基础设施与多雷达约定 | - | ✅ 已完成 | `.lgv` 读写、录制/回放、多实例规范 |
| **Phase 2** | 多雷达、多船型、多码头数据采集与标定 | 1-3 天 | ⏳ 部分完成 | 配置文件+多场景数据集 |
| **Phase 3** | ROI/海面/离群点预处理 | - | ✅ 已完成 | 5 种滤波器、JSON 配置、UI 面板 |
| **Phase 4** | 岸线识别与状态估计（V1+预留 V2/V3） | 1-2 周 | 📋 **待开发** | `DockingAlgorithm` 模块 |
| **Phase 5** | 多雷达 UDP 通信与异常保护 | 3-4 天 | 📋 待开发 | 统一协议 + `DockingPublisher` |
| **Phase 6** | 实船多环境调试与参数沉淀 | 持续 | ⏳ 待执行 | 各船型/码头参数集 |
| **Phase 7** | Headless 多实例部署 | - | ✅ 框架完成 | `main_headless.cpp`、日志滚动 |

### 当前进度概览

```
Phase 1: ████████████████████ 100%  ✅ 数据基础设施
Phase 2: ████████░░░░░░░░░░░░  40%  ⏳ 数据采集（部分）
Phase 3: ████████████████████ 100%  ✅ 预处理算法
Phase 4: ░░░░░░░░░░░░░░░░░░░░   0%  📋 岸线识别 ← 下一步
Phase 5: ░░░░░░░░░░░░░░░░░░░░   0%  📋 UDP 通信
Phase 6: ░░░░░░░░░░░░░░░░░░░░   0%  ⏳ 现场调试
Phase 7: ████████████░░░░░░░░  60%  ✅ Headless 框架
```

---

## 附录（可复用 1.0 版内容并按多雷达场景更新）

- **附录 A：数据采集场景清单**（扩展为多雷达、多码头版本）；
- **附录 B：现场测量任务**（增加雷达-船体外参、U 型码头环境记录项）；
- **附录 C：软件配置与硬件需求**（补充多实例运行的资源估算）。

---

## 已实现模块清单

### 核心模块

| 模块 | 头文件 | 实现文件 | 描述 |
| :--- | :--- | :--- | :--- |
| `DeviceManager` | `device_manager.h` | `device_manager.cpp` | Livox 设备管理 Facade |
| `DataProcessor` | `data_processor.h` | `data_processor.cpp` | IMU 融合、时间同步、姿态解算 |
| `PointCloudProcessor` | `processor.h` | `processor.cpp` | 点云帧队列、滤波管线、快照发布 |
| `Renderer` | `renderer.h` | `renderer.cpp` | VTK 点云渲染 |
| `Streamer` | `streamer.h` | `streamer.cpp` | `.lgv` 文件读写 |
| `Replayer` | `replayer.h` | `replayer.cpp` | 回放控制（倍速/暂停/Seek） |

### 滤波器模块

| 滤波器 | 头文件 | 实现文件 | 描述 |
| :--- | :--- | :--- | :--- |
| `DistanceFilter` | `distance_filter.h` | `distance_filter.cpp` | 距离范围过滤 |
| `CropBoxFilter` | `crop_box_filter.h` | `crop_box_filter.cpp` | ROI 裁剪 |
| `SeaSurfaceFilter` | `sea_surface_filter.h` | `sea_surface_filter.cpp` | 海面滤除 |
| `StatisticalOutlierFilter` | `statistical_outlier_filter.h` | `statistical_outlier_filter.cpp` | 统计离群点去除 |
| `VoxelFilter` | `voxel_filter.h` | `voxel_filter.cpp` | 体素下采样 |

### 配置与工具

| 模块 | 文件 | 描述 |
| :--- | :--- | :--- |
| `AppConfig` | `app_config.h/cpp` | JSON 配置加载/保存 |
| `Logger` | `logger.h` | spdlog 日志封装（按日期目录+滚动） |
| `ColorMap` | `color_map.h/cpp` | 点云着色方案 |
| `CameraInteractor` | `camera_interactor.h/cpp` | VTK 相机交互器 |

### UI 组件

| 组件 | 文件 | 描述 |
| :--- | :--- | :--- |
| `PointCloudWgt` | `point_cloud_wgt.h/cpp` | 主窗口控件 |
| UI 定义 | `ui/point_cloud_wgt.ui` | Qt Designer UI |
