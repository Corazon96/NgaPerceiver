# 无人艇靠离泊感知系统架构设计（v2，多雷达多实例）

本架构设计基于现有 LingerPerceiver 项目，面向“一船多雷达、多船型、多码头形状（直线/L/U 型）”的工程需求，对系统进行模块划分与职责定义，明确多进程多实例部署方案。

---

## 1. 总体架构概览

系统自下而上分为四层：

1. **基础设施层（Infrastructure Layer）**
   - Livox SDK2（硬件驱动）
   - `Streamer`（.lgv 文件录制/回放）
   - 配置系统（运行时配置，JSON/INI 等）
2. **设备层（Device Layer）**
   - `DeviceManager`（设备管理与 Livox SDK2 封装）
   - `DataProcessor`（时间同步与 IMU/姿态推算）
   - `Replayer`（录制/回放调度）
3. **处理层（Processing Layer）**
   - `PointCloudProcessor`（点云坐标变换与帧缓冲）
   - 滤波管线（`Filter` 基类及各子类）
   - `DockingAlgorithm`（靠泊算法：预处理、岸线识别、状态估计）
   - `DockingPublisher`（靠泊结果 UDP 发送模块）
4. **应用层（Application Layer）**
   - GUI 调试应用：`main.cpp` + Qt/VTK + `PointCloudWgt` + `Renderer`
   - Headless 服务：`main_headless.cpp`，仅保留设备层+处理层+通信模块

### 1.1 核心数据流

- **采集路径**：
  - Livox 硬件 → Livox SDK2 回调 → `DeviceManager::enqueuePacket` → 点云帧构建 → `onFrameWithPose` 回调 → `PointCloudProcessor::enqueue` → 滤波+坐标变换 → `DockingAlgorithm::process` → `DockingPublisher::publish` → UDP → 无人艇控制系统。

- **录制/回放路径**：
  - 录制：`DeviceManager` 在 `frameDispatcher_` 中调用 `Replayer::writeFrame` → `Streamer::writeFrame` 异步写入 `.lgv`；
  - 回放：`DeviceManager::startReplay` → `Replayer` 读 `.lgv` → 同样通过 `onFrameWithPose` 将帧送入 `PointCloudProcessor` 与 `DockingAlgorithm`，逻辑与实时采集统一。

---

## 2. 坐标系与几何关系

为了支持多雷达、多船型与多码头几何形态，需要在文档层面统一以下坐标系约定：

1. **传感器坐标系 S（Sensor Frame）**
   - Livox 点云原生坐标：原点在雷达，X/Y/Z 定义依据 Livox 官方文档；
   - 该坐标系中点云用于本地几何预处理（如 ROI、距离滤波等）。

2. **船体坐标系 B（Boat/Body Frame）**
   - 原点：推荐设在船体几何中心或控制系统约定的基准点；
   - 轴向：
     - X 轴：指向船首（Forward）；
     - Y 轴：指向左舷（Port）；
     - Z 轴：指向上方（Up）。
   - 靠泊状态（距离、角度）最终统一在 B 系下输出。

3. **世界/环境坐标系 W（World Frame，可选）**
   - 如需对码头几何进行长期建模或跨多航次对齐，可定义 W；
   - 当前阶段可暂时不在实现中显式使用，只在文档中预留。

### 2.1 雷达外参表示

对于每个雷达实例，定义从 S 到 B 的刚体变换：

- $T_{S\rightarrow B} = (R_{S\rightarrow B}, t_{S\rightarrow B})$
- 其中：
  - $t_{S\rightarrow B} = (x, y, z)$：雷达在船体坐标系 B 中的位置（单位：米）；
  - $R_{S\rightarrow B}$：雷达朝向相对于 B 的旋转，初期可简化为 yaw 旋转。

该外参由现场标定得到，并存放在每个实例的配置文件中（例如 `sensor_x_m`, `sensor_y_m`, `sensor_z_m`, `sensor_yaw_deg`）。

`PointCloudProcessor` 中应用该外参，将传感器坐标系点云转换至船体坐标系，为后续靠泊算法提供统一输入。

---

## 3. 模块职责与接口

### 3.1 设备层

#### 3.1.1 `DeviceManager`

- 角色：**Facade**，统一管理 Livox 设备、录制与回放逻辑，对上层提供简洁接口。
- 主要职责：
  - 初始化 Livox SDK2，管理设备连接与状态；
  - 在回调中快速缓存原始数据包，并在后台线程中构建点云帧；
  - 使用 `DataProcessor` 同步时间戳、处理 IMU 数据；
  - 与 `Replayer` 协作完成录制与回放；
  - 暴露 `onFrameWithPose` 回调给上层模块（`PointCloudProcessor`）。

#### 3.1.2 `DataProcessor`

- 角色：时间与姿态处理模块。
- 职责：
  - 使用系统时间与设备时间计算统一时间戳（纳秒）；
  - 对 IMU 数据进行零偏校准、死区滤波与简单姿态积分；
  - 提供 `getPoseAt` 接口，为需要按时间插值姿态的模块服务。

#### 3.1.3 `Replayer`

- 角色：录制/回放控制器。
- 职责：
  - 调用 `Streamer` 写入/读取 `.lgv` 文件；
  - 实现倍速、暂停、Seek、预加载等高级功能；
  - 将回放帧通过回调送入 `DeviceManager` → 上层处理链。

### 3.2 处理层

#### 3.2.1 `PointCloudProcessor`

- 角色：点云处理流水线的“调度器与缓冲器”。
- 主要职责：
  - 接收来自 `DeviceManager` 的逐帧点云与姿态；
  - 通过内部队列与工作线程执行：
    - 预滤波（如距离、ROI、海面滤除、离群点）；
    - 坐标变换（从 S 到 B）；
    - 帧缓冲与按时间窗口的保留/清理；
  - 将预处理后的点云快照回调给：
    - GUI 模式下的 `Renderer`（用于可视化）；
    - 靠泊算法模块 `DockingAlgorithm`（用于计算状态）。

#### 3.2.2 滤波模块（`Filter` 及子类）

- 已实现的滤波器包括：
  - `DistanceFilter`：按距离过滤点；
  - `VoxelFilter`：体素下采样（降采样与加速）；
  - `CropBoxFilter`：ROI 裁剪；
  - `SeaSurfaceFilter`：基于高度的海面滤除；
  - `StatisticalOutlierFilter`：统计离群点去除；
  - `DensityFilter`：密度滤波（低密度噪声去除）；
  - `MotionFilter`：运动滤波（静态/动态点分离）。
- 所有滤波器：
  - 继承自抽象基类 `Filter`；
  - 通过 `PointCloudProcessor::addFilter` 挂入流水线，支持前置/后置两类执行顺序；
  - 参数由运行时配置加载，可选由 UI 调整。

#### 3.2.3 `DockingAlgorithm`

- 角色：靠泊核心算法模块。
- 输入：
  - 在船体坐标系 B 下的预处理点云；
  - 时间戳/姿态信息（必要时）。
- 输出：
  - `DockingState`：
    - 距离 D（船体参考点至目标岸线的垂直距离）；
    - 角度 θ（船首方向与岸线方向的夹角）；
    - 置信度、状态码；
    - 岸线方程参数、内点数等调试信息。
- 内部结构（建议）：
  - `PreProcessor`：在算法内部可重用部分预处理逻辑（如针对特定扇区的过滤）；
  - `ShorelineDetector`：基于 RANSAC 等方法，在前/侧向扇区中检测岸线；
  - `StateEstimator`：在 B 系下完成几何计算与状态封装。
- 演进版本：
  - V1：单直线岸线（单实例单扇区，当前多雷达多实例部署的主力模式）；
  - V2：多扇区/多线段（主要面向“单雷达覆盖多方向”或未来在单进程内汇聚多雷达的场景）；
  - V3：U 型/复杂码头（在 V2 基础上的多边关系推断，属于长期扩展方向）。

#### 3.2.4 `DockingPublisher`

- 角色：UDP 通信模块。
- 职责：
  - 将 `DockingState` 按协议序列化为 20 字节二进制 `DockingPacket`；
  - 通过 UDP 向控制系统定期发送当前状态；
  - 支持异步发送，避免阻塞算法/渲染线程。
- 通信协议（`DockingPacket`，20 字节）：
  - `timestamp_ns` (8 字节)：时间戳（纳秒）；
  - `sensor_id` (1 字节)：雷达编号 (1=前, 2=左舷, 3=右舷)；
  - `status` (1 字节)：状态码 (0=未检测, 1=正常, 2=低置信度)；
  - `confidence` (1 字节)：置信度 0-100；
  - `reserved` (1 字节)：保留对齐；
  - `distance_m` (4 字节)：检测距离（米）；
  - `angle_deg` (4 字节)：边缘角度（度）。
- 设计说明：
  - 不含雷达外参，坐标转换由控制系统负责；
  - 小端字节序，1 字节对齐。

### 3.3 应用层

#### 3.3.1 GUI 调试应用

- 入口：`main.cpp`
- 组件：
  - `QApplication` + `PointCloudWgt`（UI 控件与用户交互）；
  - `Renderer`（VTK 渲染，显示点云与拟合岸线）；
  - `DeviceManager` + `PointCloudProcessor` + `DockingAlgorithm` 组成数据处理链；
- 用途：
  - 在开发与现场调试阶段可视化点云与算法结果；
  - 提供参数调整与状态监控界面。

#### 3.3.2 Headless 服务应用

- 入口：`main_headless.cpp`（已实现）
- 组件：
  - 配置加载模块（读取 JSON 等）；
  - `DeviceManager`、`PointCloudProcessor`、`DockingAlgorithm`、`DockingPublisher`；
- 特点：
  - 不依赖 Qt/VTK，资源占用小；
  - 可在工控机上以服务形式运行，多实例并存。

---

## 4. 一船多雷达多进程部署方案

### 4.1 部署拓扑

- 假设一艘船上安装 3 个雷达：
  - 前向：`sensor_id = 1`（front）
  - 左舷：`sensor_id = 2`（port）
  - 右舷：`sensor_id = 3`（starboard）
- 在同一工控机上启动 3 个 headless 实例：

```text
linger_perceiver_service --config config_front.json
linger_perceiver_service --config config_port.json
linger_perceiver_service --config config_starboard.json
```

- 每个实例：
  - 连接对应 Livox 雷达；
  - 使用各自的雷达-船体外参与预处理参数；
  - 通过 UDP 向控制系统发送各自的 `DockingPacket`。

### 4.2 时间同步与日志

- 要求：
  - 所有实例运行在同一主机或同一时间源（统一系统时间）；
  - `DataProcessor::syncTimestamp` 在每个实例中将设备时间转换为统一系统时间；
  - 控制系统可据此在时间轴上对多雷达数据进行关联与融合（如有需要）。

- 日志建议：
  - 每个实例独立日志文件，如：
    - `log_front.txt`
    - `log_port.txt`
    - `log_starboard.txt`
  - 日志内容中包含 `sensor_id` 与配置文件路径，便于问题追踪。

### 4.3 多雷达间协同的边界

- 当前版本（v2）中：
  - **不在单一进程内做多雷达融合**；
  - 各雷达独立输出“本地观察到的岸线与靠泊状态”；
  - 多雷达信息的最终融合由控制系统或上层决策模块完成。

- 中长期可选扩展：
  - 新增“多雷达融合服务”，只接收各实例的 UDP 数据进行更高级别环境感知；
  - 或在单个进程内管理多个 `DeviceManager` 实例，做内部融合。

---

## 5. Headless 与 GUI 模式的构建与切换

### 5.1 CMake 构建选项

- 新增选项：`BUILD_HEADLESS`（布尔）
  - `OFF`（默认）：构建带 GUI 的 `linger_perceiver` 可执行文件；
  - `ON`：构建无界面的 `linger_perceiver_service`。

### 5.2 模式差异对比

| 项目 | GUI 模式 | Headless 模式 |
|------|----------|----------------|
| 入口 | `main.cpp` | `main_headless.cpp` |
| 依赖 | Qt5、VTK、PCL、Livox SDK2、Eigen | PCL、Livox SDK2、Eigen |
| 功能 | 点云渲染、UI 控制、算法可视化 | 数据处理+算法+UDP 通信 |
| 用途 | 开发调试、现场可视化 | 工控机长期运行 |

### 5.3 Headless 运行实践要点

- 通过配置文件驱动所有参数（雷达 IP、外参、预处理与 RANSAC 参数、UDP 目标地址等）；
- 保证异常退出时正确关闭 Livox 设备连接与线程；
- 建议配合系统服务/守护进程使用，支持自动重启与日志轮转。

---

## 6. 扩展与演进

- **多码头形状支持**：
  - 通过在 `DockingAlgorithm` 中扩展多扇区、多线段识别；
  - 在配置中加入“码头类型/开口方向”等高层语义参数；
  - 逐步演进到 U 型与复杂几何结构的鲁棒识别。

- **多雷达融合（后续阶段）**：
  - 在当前多实例架构上，增加独立融合服务或在控制系统侧完成融合；
  - 复用本架构中统一的船体坐标系与时间同步约定。

- **算法替换与升级**：
  - 未来可在 `DockingAlgorithm` 内替换/升级 RANSAC 为更复杂的几何或学习算法；
  - 只要保持 `DockingState` 输出接口稳定，对外模块基本无感知。

---

本架构设计为后续代码实现与文档扩展提供统一参考。如需进一步细化某个子模块（例如 `DockingAlgorithm` 内部类图或 `DockingPublisher` 协议状态机），可在本文件基础上新增专题设计文档。